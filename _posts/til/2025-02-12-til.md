---
title: "[250212] TIL"
excerpt: ""

categories:
  - TIL
tags:
  - [TIL]

permalink: /blog/til/250212

toc: true
toc_sticky: true

date: 2025-02-12
last_modified_at: 2025-02-12
---


# 오늘 한 것

## 클라이언트 - 서버

### 클라이언트

- 클라이언트는 서버에게 필요한 자원을 요청하는 역할이다.
- 사용자와 직접 상호작용을 하고 UI/UX를 제공한다.
- 예시: 웹 브라우저, 모바일 앱, 데스크톱 애플리케이션

### 서버

- 서버는 자원을 관리하고 다수의 클라이언트에게 필요한 자원을 응답하는 역할이다.
- 예시: 웹 서버, 데이터베이스 서버, 파일 서버

## DNS (Domain Name System)

- 도메인 이름을 IP 주소로 변환하는 시스템
- 인터넷의 전화번호부 역할이라고 생각하면 더 와닿는다.
- 예시: [www.google.com](http://www.google.com) → 172.217.161.36
- IP 주소보다 도메인 이름을 사용해서 기억하기가 쉬운 것이 장점이고, 서버 IP가 바뀌더라도 도메인은 유지 할 수 있다.
- 로드 밸런싱이 가능하다. → 하나의 도메인 주소에 여러 개의 IP 주소가 가능
    - 로드 밸런싱이란, 서버에게 가해지는 부하를 분산 시키는 기술이다. 다수의 서버로 트래픽을 균등하게 분배 가능

## Forward Proxy

[Client] → [Forward Proxy] → [Internet] → [Server]

- 클라이언트와 인터넷 사이에 위치한 중계서버
- 클라이언트의 요청을 대신 전달하고 응답을 받아옴
- 주요 기능
    - 캐싱, 익명성 ( 실제 Client IP 숨김), 접근 제어 (허용 하는 네트워크 말고는 차단)
- Reverse Proxy 라고도 있는데 서버를 보호하고 제어함
    - [Internet] → [Reverse Proxy] → [Server]

## OSI 7계층

- 각 7계층이 독립적으로 동작하면서 전체 네트워크가 작동함

### 7. 응용 계층 ( Application Layer )

- 역할 : 사용자와 직접 상호작용
- 프로토콜 : HTTP, FTP, SMTP, DNS

```java
HTTP Request/Response
GET /index.html HTTP/1.1 // GET 메서드, 요청하는 리소스 경로, HTTP 버전
Host: www.example.com  // 호스트 헤더
```

### 6. 표면 계층 ( Presentation Layer )

- 역할 : 데이터 형식 변환, 암호화
- 기능 : 인코딩, 암호화, 압축

```java
JAPG, PNG 이미지 변환
ASCII <-> EBCDIC // (변환,7비트 인코딩 -> 8비트 인코딩)
SSL/TLS 암호화
```

- HTTPS 는 보안을 위해 표현 계층의 SSL/TLS 사용하는 HTTP 이다.

### 5. 세션 계층 ( Session Layer )

- 역할 : 통신 세션 관리 - 논리적인 연결을 관리함
- 기능 : 연결 수립, 유지, 종료

```java
NetBIOS (컴퓨터 간 통신 세션 관리)
RPC ( Remote Procedure Call, 원격 프로시저 호출 )
SQL ( 데이터 베이스 세션 관리 )
세션 토큰 관리
```

### 4. 전송 계층 ( Transport Layer )

- 역할 : 신뢰성 있는 데이터 전송
- 프로토콜 : TCP, UDP

```java
TCP 연결:
SYN → SYN/ACK → ACK
포트 번호: 80, 443
```

### 3. 네트워크 계층 ( Network Layer )

- 역할 : 패킷 라우팅, 주소 지정
- 프로토콜 : IP, ICMP, ARP

```java
IP 주소: 192.168.0.1
라우팅 테이블 관리
```

### 2. 데이터링크 계층 ( Data Link Layer )

- 역할 : 물리적 주소 지정, 오류 검출
- 프로토콜 : Ethernet, MAC
    - 네트워크 장비의 고유 물리 주소
    - 48비트 길이
    - 전 세계적으로 유일한 값이고 제조 시 부여 된다.
    - NIC(네트워크 카드)에 고정 된다.

```java
MAC 주소: 00:00:5e:00:53:af
프레임 단위 전송
```

### 1. 물리 계층 ( Physical Layer )

- 역할 : 비트 단위 데이트  전송
- 매체 : 케이블, 허브, 리피터

```java
전기 신호, 광 신호
RS-232C, 이더넷 케이블
```

### 데이터 흐름

```java
[응용] → [표현] → [세션] → [전송] → [네트워크] → [데이터링크] → [물리]
     데이터 캡슐화 (Encapsulation)
     
[물리] → [데이터링크] → [네트워크] → [전송] → [세션] → [표현] → [응용]
     데이터 역캡슐화 (Decapsulation)
```

### 각 계층별 PDU ( Protocol Data Unit )

```java
L7-L5: 데이터 (Data)
L4: 세그먼트 (Segment)
L3: 패킷 (Packet)
L2: 프레임 (Frame)
L1: 비트 (Bit)
```

### Mac 과 IP 비교

```java
MAC 주소:
- 물리적 주소
- L2 계층
- 변경 어려움
- 전역적으로 유일

IP 주소:
- 논리적 주소
- L3 계층
- 쉽게 변경 가능
- 네트워크별로 할당
```

## TCP ( Transmission Control Protocol )

- 정의 : 신뢰성 있는 데이터 전송을 보장하는 프로토콜
- 계층 : 전송 계층 ( L4 )
- 특징 : 연결 지향적 (두 개의 호스트를 연결) , 순서 보장, 오류 검출

## 3way-handshake

- TCP/IP 네트워크 프로토콜에서 연결을 초기화 하는 과정임

```java
[클라이언트]          [서버]
     |                 |
     |---SYN(seq=x)-->|   # 1단계
     |                 |
     |<-SYN+ACK-------|   # 2단계
     |   (seq=y,ack=x+1)  
     |                 |
     |---ACK(ack=y+1)->|   # 3단계
     |                 |
```

### 1단계 : SYN ( Synchronzie ) 단계

```java
클라이언트 → 서버
- SYN 플래그 설정
- 초기 시퀀스 번호(ISN) 전송
```

- 클라이언트가 서버에 접속을 요청하는 SYN 패킷을 보냄
- 패킷에는 클라이언트가 세션을 시작할 준비가 되었다는 신호랑, 클라이언트 초기 시퀀스 번호(ISN) 이 포함
- 패킷 하나하나에 번호를 붙이고, 패킷들이 빠진게 있는지 확인할 수 있음
- `예) 클라이언트 -> 서버: SYN (SEQ = 1000)`
    - 클라이언트 : “내 시작 번호는 1000이야”

### 2단계 :  SYN-ACK ( Synchronize-Acknowledgment ) 단계

- 서버가 SYN 요청을 받고, 클라이언트에게 SYN-ACK 패킷을 보냄
- 서버의 초기 스퀀스 번호도 포함되어있음
- `예) 서버 -> 클라이언트: SYN-ACK (SEQ = 2000, ACK = 1000 + 1 = 1001)`
- 서버 : “내 시작 번호는 2000이고, 너의 다음 번호는 1001을 기대할게”

### 3단계 : ACK ( Acknowledgment ) 단계

- 클라이언트가 서버의 시퀀스 번호를 받았고, 서로 간의 연결이 정상적으로 수립 되었다는 것을 확인
- `예) 클라이언트 -> 서버: ACK (SEQ = 1001, ACK = 2000 + 1 = 2001)`
- 클라이언트 : “알겠어, 너의 다음 번호는 2001을 기대할게”

**SEQ ( Sequence Number )**

- 정의 : 전송하는 데이터의 순서 번호
- 초기값 : 보안상의 이유로 랜덤하게 선택 된다.
- 위 예시는 클라이언트 초기 SEQ = 1000 (랜덤)

**ACK ( Acknowledgment Number )**

- 정의 : 다음에 받기를 기대하는 SEQ 번호
- 계산 : 받은 SEQ + 1
- “여기까지 받았으니, 다음 번호를 보내주세요.”

**ESTABLISHED**

- 연결이 수립된 것을 확인하고 데이터 전송 준비 완료 됐음을 의미

**와이어샤크**

- 네트워크 패킷 분석하는 도구, 패킷을 뜯어볼 수 있음

### 흐름제어 ( Flow Control )

- 목적 : 송신자와 수신자 간의 데이터 처리 속도 차이 해결
- 방식 : 수신자의 버퍼 상태에 따라 송신 속도 조절
- 수신자 버퍼 오버플로우 방지

```java
[수신자 버퍼]
여유 공간: 1000바이트
→ 송신자에게 윈도우 크기 1000 알림
→ 송신자는 최대 1000바이트까지만 전송
```

### 혼잡제어 ( Congestion Control )

- 목적 : 네트워크 혼잡 상태 관리
- 방식 : 네트워크 상황에 따라 전송 속도 조절
- 패킷 손실 최소화

### 슬라이딩 윈도우 ( Sliding Window )

- 목적 : 효율적인 데이터 전송
- 방식 : 여러 패킷을 연속해서 전송하고 한번에 확인
- 연속 전송으로 효율성 향상

### slow start

- 목적 : 초기 네트워크 부하 방지
- 방식 : 전송량을 점진적으로 증가
- 안전한 초기 연결, 점진적 속도 증가

## UDP

- 빠르고 간단한 통신을 위해 연결 설정 없이 데이터를 전송하는 네트워크 프로토콜
- TCP 보다는 신뢰성 낮습니다.
- 빠른 전송이 최대 장점

## CDN

- 사용자에게 가장 가까운 서버에서 응답을 함
- 로딩 시간을 줄이고, 대역폭 사용을 최적화하며, 전반적인 사용자 경험을 향상 시킴
- 사용자가 여기 저기 흩어져 있어서 여러 지역에 CDN 이라는 거점을 만들어서 사용자에게 응답을 전달할 때 좀 더 빠르게 전달하는 것

```java
Cloudflare, Amazon CloudFront, Microsoft Azure CDN, Google Cloud CDN
```