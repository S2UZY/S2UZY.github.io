---
title: "[250812] TIL"
excerpt: ""

categories:
  - TIL
tags:
  - [TIL]

permalink: /blog/til/250812

toc: true
toc_sticky: true

date: 2025-08-12
last_modified_at: 2025-08-12
---

# Today I Learned (2025-08-12)

# React props, state에 대해 설명해주세요.

- react props는 부모 컴포넌트로부터 받은 읽기 전용 데이터를 말합니다. props 값은 자식 컴포넌트에서 변경 할 수 없고 props 가 변하면 컴포넌트가 리렌더링 대상이 됩니다.

- state는 컴포넌트 내부에서 관리하는 동적인 데이터를 말합니다. state가 변하면 컴포넌트가 다시 리렌더링 됩니다.

# props가 자식 컴포넌트에서 변하지 않는 이유는 무엇인가요?

- 자식 컴포넌트에서 변하지 않는 이유는, 리액트에서 데이터가 단방향으로 흐르기때문입니다.
- 만약 props가 변경될 수 있다면 자식의 동작이 외부 상태 변화에 종속될 수 있어서 독립성이 낮아집니다. 그럼 외부에서 무엇을 하든 내부로직에서 예측하기 어려워집니다. props가 불변으로 유지됨으로써 독립성이 올라가고 재사용성이 높아지고 코드의 캡슐화가 강화됩니다.

# 코딩 테스트 문제 풀기

## [배열] 모의고사

- 문제 2개 품
  https://school.programmers.co.kr/learn/courses/30/lessons/42840?language=javascript

1번 수포자 : 1 2 3 4 5 반복
2번 수포자 : 2 1 2 3 2 4 2 5 반복
3번 수포자 : 3 3 1 1 2 2 4 4 5 5 반복

우선 최대 10,000문제니깐, 10^4
배열 한개씩 비교하면 3N X
한 번만 돌면 될 듯 O

1초에 10^8 연산 할 수 있으니깐 10,000개 입력값이 들어와도 0.0003초 걸린다.
즉 완탐으로 풀어도 된다 !

근데 카운트를 해서 1번 2번 3번을 어떻게 넣을지가 고민된다.
1, 2, 3번이라는 사람 정보를 갖고 있으면서도.. 카운트 갯수도 갖고 있어야한다.
객체로 해야하나 ? 객체가 sort 가 되는지 모르겠다.
아니면 2차원 배열?

우선 2차원 배열로 풀어봐야겠다.

```js
function solution(answers) {
  let answer = [];
  let a = [1, 2, 3, 4, 5];
  let b = [2, 1, 2, 3, 2, 4, 2, 5];
  let c = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];
  let count = [
    [1, 0],
    [2, 0],
    [3, 0],
  ];

  for (let i = 0; i < answers.length; i++) {
    if (answers[i] == a[i % 5]) count[0][1] += 1;
    if (answers[i] == b[i % 8]) count[1][1] += 1;
    if (answers[i] == c[i % 10]) count[2][1] += 1;
  }

  count.sort((a, b) => b[1] - a[1]);

  const max = count[0][1];

  for (item of count) {
    if (item[1] == max) answer.push(item[0]);
  }

  return answer;
}
```

# 책 풀이

- 저랑 어떤 부분을 다르게 풀었는지 생각해보았을때, Math.max를 사용해서 가장 큰 수를 구했습니다.
- 패턴을 배열로 넣었습니다.
- 문제 풀이에서는 1차원 배열로도 그냥 순서대로 넣어서 0 인덱스가 1번 수포자, 1 인덱스가 2번 수포자 이런식으로 넣어줬습니다.

```js
function solution(answers) {
  var answer = [];

  // 패턴을 배열로 넣음, 훨씬 깔끔한 것 같다.
  const patterns = [
    [1, 2, 3, 4, 5],
    [2, 1, 2, 3, 2, 4, 2, 5],
    [3, 3, 1, 1, 2, 2, 4, 4, 5, 5],
  ];

  // 수포자 점수를 저장할 배열
  const scores = [0, 0, 0];

  for (const [i, answer] of answers.entries()) {
    for (const [j, pattern] of patterns.entries()) {
      if (answer === pattern[i % pattern.length]) {
        scores[j] += 1;
      }
    }
  }

  // 가장 높은 점수 저장
  const maxScore = Math.max(...scores);
  const highestScores = [];

  for (let i = 0; i < scores.length; i++) {
    highestScores.push(i + 1);
  }

  return highestScores;
}
```

## [배열] 두 개 뽑아서 더하기

https://school.programmers.co.kr/learn/courses/30/lessons/68644?language=javascript

1. 완전탐색으로 품

```js
function solution(numbers) {
  var answer = [];

  // 반복문으로 배열의 모든 숫자를 더해서 answer에 넣는다.
  for (let i = 0; i < numbers.length; i++) {
    for (let j = i + 1; j < numbers.length; j++) {
      answer.push(numbers[i] + numbers[j]);
    }
  }

  // 중복되는 값을 set을 이용해서 없애고 오름차순으로 정렬한다.
  answer = [...new Set(answer)];
  answer.sort((a, b) => a - b);

  return answer;
}
```

### 교재 풀이

최대 개수는 100이므로 시간 복잡도는 고려하지 않아도 됨

```js
function solution(numbers) {
  var answer = [];

  for (let i = 0; i < numbers.length; i++) {
    for (let j = 0; j < i; j++) {
      answer.push(numbers[i] + numbers[j]);
    }
  }

  answer = [...new Set(answer)].sort((a, b) => a - b);

  return answer;
}
```
